<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Aperture Uplink | Neural Link</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body {
            background-color: #050505;
            color: #00f0ff;
            font-family: 'JetBrains Mono', monospace;
            overflow: hidden;
            height: 100vh;
        }

        .scanline::before {
            content: " ";
            display: block;
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background: linear-gradient(rgba(18, 16, 16, 0) 50%, rgba(0, 0, 0, 0.25) 50%), linear-gradient(90deg, rgba(255, 0, 0, 0.06), rgba(0, 255, 0, 0.02), rgba(0, 0, 255, 0.06));
            z-index: 2;
            background-size: 100% 2px, 3px 100%;
            pointer-events: none;
        }

        .blinking-cursor::after {
            content: "|";
            animation: blink 1s step-end infinite;
        }

        @keyframes blink {

            0%,
            100% {
                opacity: 1;
            }

            50% {
                opacity: 0;
            }
        }

        .ai-msg {
            color: #00f0ff;
            margin-bottom: 1rem;
            white-space: pre-wrap;
        }

        .user-msg {
            color: #ffffff;
            margin-bottom: 1rem;
            text-align: right;
            opacity: 0.8;
        }

        .system-msg {
            color: #ff003c;
            margin-bottom: 1rem;
            font-weight: bold;
        }

        input {
            background: transparent;
            border: none;
            outline: none;
            color: white;
            width: 80%;
            font-family: inherit;
        }

        /* Video Uplink Side Panel - Simplified for Stability */
        .identity-overlay {
            position: fixed;
            top: 0;
            right: 0;
            bottom: 0;
            width: 50%;
            background: rgba(10, 20, 30, 0.98);
            border-left: 1px solid #00f0ff;
            padding: 2rem;
            z-index: 9999;
            box-shadow: -10px 0 50px rgba(0, 240, 255, 0.1);

            /* Hidden State */
            display: none;
            opacity: 0;
            transform: translateX(100%);
            /* Fully off-screen */
            transition: opacity 0.5s ease, transform 0.5s ease;

            flex-direction: column;
            justify-content: center;
            backdrop-filter: blur(10px);
        }

        .identity-overlay.active {
            display: flex !important;
            opacity: 1 !important;
            animation: slideInPanel 0.8s cubic-bezier(0.23, 1, 0.32, 1) forwards !important;
        }

        @keyframes slideInPanel {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @media (max-width: 768px) {
            .identity-overlay {
                width: 100%;
                border-left: none;
                border-top: 1px solid #00f0ff;
                top: auto;
                height: 60%;
                transform: translateY(100%);
            }

            .identity-overlay.active {
                transform: translateY(0) !important;
            }
        }
    </style>
</head>

<body class="scanline flex flex-col p-6 relative">

    <!-- Header -->
    <div class="flex justify-between items-center border-b border-[#00f0ff]/30 pb-4 mb-4">
        <div class="text-xs tracking-[0.2em] text-[#00f0ff]/60">SECURE_CHANNEL_V9</div>
        <div class="text-xs tracking-[0.2em] text-[#00f0ff]/60 flex items-center gap-2">
            <div class="w-2 h-2 bg-[#00f0ff] rounded-full animate-pulse"></div>
            LIVE_UPLINK
        </div>
    </div>

    <!-- Chat Log (The Terminal) -->
    <div id="chat-container" class="flex-1 overflow-y-auto mb-4 scrollbar-hide">
        <!-- Messages will be injected here -->
        <div class="system-msg">INITIALIZING NEURAL HANDSHAKE...</div>
    </div>

    <!-- Input Area -->
    <div id="input-area" class="border-t border-[#00f0ff]/30 pt-4 flex items-center relative z-10">
        <span class="mr-2 text-[#00f0ff]">></span>
        <input type="text" id="user-input" placeholder="Awaiting Input..." autocomplete="off">
    </div>

    <!-- Video Manifesto Interface (The Uplink) -->
    <div id="video-uplink" class="identity-overlay items-center">
        <h2 class="text-2xl font-bold mb-1 tracking-widest text-[#ff003c] animate-pulse">ESTABLISHING VISUAL LINK...
        </h2>
        <p class="text-xs text-gray-400 mb-4 font-mono">REC. PROTOCOL ACTIVE. STATE YOUR MANIFESTO (30s).</p>

        <div class="relative w-full aspect-video bg-black border border-[#ff003c]/50 mb-4 overflow-hidden group">
            <video id="webcam-feed" class="w-full h-full object-cover" autoplay muted playsinline></video>

            <!-- HUD Overlay -->
            <div class="absolute inset-0 border-[1px] border-[#ff003c]/20 pointer-events-none"></div>
            <div class="absolute top-2 left-2 text-[10px] text-[#ff003c] font-mono">REC_MODE: MANIFESTO</div>
            <div class="absolute bottom-2 right-2 text-[10px] text-[#ff003c] font-mono flex items-center gap-1">
                <div class="w-2 h-2 bg-[#ff003c] rounded-full animate-blink hidden" id="rec-indicator"></div>
                LIVE
            </div>

            <!-- Recording Timer -->
            <div class="absolute top-2 right-2 text-xl font-bold text-[#ff003c] hidden" id="timer">00:30</div>
        </div>

        <div class="flex gap-4 w-full" id="controls">
            <button id="btn-record"
                class="flex-1 bg-[#ff003c]/10 border border-[#ff003c] py-3 text-sm font-bold tracking-widest hover:bg-[#ff003c]/20 transition-all text-[#ff003c]">
                INITIATE RECORDING
            </button>
            <button id="btn-stop"
                class="hidden flex-1 bg-gray-800 border border-gray-600 py-3 text-sm font-bold tracking-widest hover:bg-gray-700 transition-all text-white">
                TERMINATE LINK
            </button>
            <button id="btn-upload"
                class="hidden flex-1 bg-[#00f0ff]/10 border border-[#00f0ff] py-3 text-sm font-bold tracking-widest hover:bg-[#00f0ff]/20 transition-all text-[#00f0ff]">
                TRANSMIT DATA
            </button>
        </div>

        <!-- Metadata Form (Hidden but submitted with video) -->
        <div class="w-full mt-4 space-y-2" id="meta-fields">
            <input type="text" id="meta-name" placeholder="OPERATIVE NAME"
                class="w-full bg-black/50 border border-[#00f0ff]/30 p-2 text-white text-xs font-mono">
            <input type="text" id="meta-role" placeholder="TARGET DESIGNATION (ROLE)"
                class="w-full bg-black/50 border border-[#00f0ff]/30 p-2 text-white text-xs font-mono">
        </div>

        <div id="upload-status" class="mt-2 text-xs text-[#00f0ff] hidden">UPLOADING PACKET...</div>
    </div>

    <script>
        const chatContainer = document.getElementById('chat-container');
        const userInput = document.getElementById('user-input');
        const inputArea = document.getElementById('input-area');
        const videoUplink = document.getElementById('video-uplink');
        const webcamFeed = document.getElementById('webcam-feed');
        const btnRecord = document.getElementById('btn-record');
        const btnStop = document.getElementById('btn-stop');
        const btnUpload = document.getElementById('btn-upload'); // Now "Submit Response"
        const timerCallback = document.getElementById('timer');
        const recIndicator = document.getElementById('rec-indicator');

        let currentStage = 'start';
        const SESSION_ID = 'session_' + Math.random().toString(36).substr(2, 9);
        let mediaRecorder;
        let recordedChunks = [];
        let videoBlob;
        let countdown;
        let isRecordingLogicActive = false;

        // Force Video Panel to be always visible for this mode
        videoUplink.classList.add('active');
        inputArea.style.opacity = '0'; // Hide text input
        userInput.disabled = true;

        // Auto-scroll logic
        function scrollToBottom() {
            chatContainer.scrollTop = chatContainer.scrollHeight;
        }

        async function typeWriter(text, element) {
            const chars = text.split('');
            element.innerHTML = '';
            for (let i = 0; i < chars.length; i++) {
                element.innerHTML += chars[i];
                await new Promise(r => setTimeout(r, 10));
                scrollToBottom();
            }
        }

        async function addMessage(text, type) {
            const div = document.createElement('div');
            div.className = type;
            chatContainer.appendChild(div);
            if (type === 'ai-msg') await typeWriter(text, div);
            else div.innerText = text;
            scrollToBottom();
        }

        // --- CORE INTERACTION LOOP ---
        async function interact(message) {
            try {
                // Interrogate AI
                const response = await fetch('http://127.0.0.1:8000/api/interview/interact', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ session_id: SESSION_ID, current_stage: currentStage, message: message })
                });

                if (!response.ok) throw new Error(`HTTP Error ${response.status}`);

                const data = await response.json();
                currentStage = data.next_stage;
                console.log(`Updated Stage: ${currentStage}`);

                // AI Speaks
                await addMessage(data.message, 'ai-msg');

                if (data.status === 'ACCESS_GRANTED') {
                    addMessage("SYSTEM: UPLINK ESTABLISHED. WELCOME TO APERTURE.", "system-msg");
                    confettiEffect(); // Celebration
                    return;
                }

                // Enable Recording for the user's turn
                resetRecordingUI();

            } catch (e) {
                console.error(e);
                addMessage("CONNECTION LOST: " + e.message, "system-msg");
            }
        }

        function resetRecordingUI() {
            // Reset UI for next question
            btnRecord.classList.remove('hidden');
            btnRecord.innerText = "INITIATE VIDEO RESPONSE";
            btnStop.classList.add('hidden');
            btnUpload.classList.add('hidden');
            webcamFeed.srcObject = null;
            startCamera(); // Restart stream
        }

        // --- CAMERA & UPLOAD LOGIC ---
        async function startCamera() {
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
                webcamFeed.srcObject = stream;
                webcamFeed.muted = true; // Mute local echo
                // Ensure it plays
                await webcamFeed.play();
            } catch (err) {
                console.error("Camera Access Denied", err);
                addMessage("SYSTEM ERROR: CAMERA ACCESS REQUIRED.", "system-msg");
            }
        }

        function getSupportedMimeType() {
            const types = [
                'video/webm;codecs=vp9',
                'video/webm;codecs=vp8',
                'video/webm',
                'video/mp4'
            ];
            for (const t of types) {
                if (MediaRecorder.isTypeSupported(t)) return t;
            }
            return '';
        }

        btnRecord.addEventListener('click', async () => {
            if (!webcamFeed.srcObject) await startCamera();
            const stream = webcamFeed.srcObject;

            const mimeType = getSupportedMimeType();
            if (!mimeType) {
                alert("CRITICAL ERROR: No supported video MIME type found.");
                return;
            }

            console.log("Using MIME:", mimeType);

            try {
                mediaRecorder = new MediaRecorder(stream, { mimeType: mimeType });
            } catch (e) {
                alert("MediaRecorder Init Failed: " + e.message);
                return;
            }

            recordedChunks = [];
            mediaRecorder.ondataavailable = e => { if (e.data.size > 0) recordedChunks.push(e.data); };

            mediaRecorder.onstop = () => {
                videoBlob = new Blob(recordedChunks, { type: mimeType });
                console.log("Blob Size:", videoBlob.size);

                if (videoBlob.size === 0) {
                    alert("ERROR: NO VIDEO DATA CAPTURED. TRY AGAIN.");
                    resetRecordingUI();
                    return;
                }

                // Playback
                webcamFeed.srcObject = null;
                webcamFeed.src = URL.createObjectURL(videoBlob);
                webcamFeed.muted = false; // Unmute for playback
                webcamFeed.controls = true;

                try {
                    webcamFeed.play();
                } catch (e) {
                    console.error("Playback failed", e);
                }

                btnStop.classList.add('hidden');
                btnUpload.classList.remove('hidden');
                btnUpload.innerText = "TRANSMIT RESPONSE (SIZE: " + Math.ceil(videoBlob.size / 1024) + "KB)";
            };

            mediaRecorder.start();
            btnRecord.classList.add('hidden');
            btnStop.classList.remove('hidden');
            timerCallback.classList.remove('hidden');
            recIndicator.classList.remove('hidden');

            let timeLeft = 60; // Increased time
            countdown = setInterval(() => {
                timeLeft--;
                timerCallback.innerText = `00:${timeLeft < 10 ? '0' + timeLeft : timeLeft}`;
                if (timeLeft <= 0) stopRecording();
            }, 1000);
        });

        function stopRecording() {
            if (mediaRecorder && mediaRecorder.state === 'recording') {
                mediaRecorder.stop();
                clearInterval(countdown);
                recIndicator.classList.add('hidden');
            }
        }
        btnStop.addEventListener('click', stopRecording);

        btnUpload.addEventListener('click', async () => {
            if (!videoBlob) return;

            // UI Feedback
            btnUpload.innerText = "TRANSMITTING...";
            btnUpload.disabled = true;

            const name = document.getElementById('meta-name').value || "Unknown Candidate";
            const role = document.getElementById('meta-role').value || "Applicant";

            const formData = new FormData();
            formData.append('session_id', SESSION_ID);
            formData.append('stage', currentStage); // Current Protocol Stage
            formData.append('name', name);
            formData.append('role', role);
            formData.append('video', videoBlob, `${SESSION_ID}_${currentStage}.webm`);

            try {
                const res = await fetch('http://127.0.0.1:8000/api/recruitment/upload', {
                    method: 'POST',
                    body: formData
                });
                const result = await res.json();

                if (result.status === 'success') {
                    addMessage("SYSTEM: DATA PACKET RECEIVED.", "system-msg");
                    // Advance the AI
                    await interact("VIDEO_UPLOAD_COMPLETE");
                }
            } catch (e) {
                alert("UPLOAD FAILED: " + e.message);
                btnUpload.disabled = false;
                btnUpload.innerText = "RETRY TRANSMIT";
            }
        });

        // Initialize
        window.onload = async () => {
            // Ask Name first? For now just start.
            await interact("INIT");
            // Ensure panel is open
            videoUplink.classList.add('active');
        };

        function confettiEffect() {
            // Placeholder for celebration
            document.body.style.backgroundColor = "#001a1a";
        }

    </script>
</body>

</html>